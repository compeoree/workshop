
# Sorted dome test 2016/06/08 19:01:44

# Frequency: 2
# Radius: 30.0
#Vertices: 36 [x, y, z] 
V = [
	[   0.000,    0.000,   30.000], #  0 0-0
	[  15.772,    0.000,   25.520], #  1 1-0
	[   4.874,   15.000,   25.520], #  2 1-1
	[ -12.760,    9.270,   25.520], #  3 1-2
	[ -12.760,   -9.270,   25.520], #  4 1-3
	[   4.874,  -15.000,   25.520], #  5 1-4
	[  20.646,   15.000,   15.772], #  6 2-0
	[  -7.886,   24.270,   15.772], #  7 2-1
	[ -25.520,    0.000,   15.772], #  8 2-2
	[  -7.886,  -24.270,   15.772], #  9 2-3
	[  20.646,  -15.000,   15.772], # 10 2-4
	[  26.833,    0.000,   13.416], # 11 3-0
	[   8.292,   25.520,   13.416], # 12 3-1
	[ -21.708,   15.772,   13.416], # 13 3-2
	[ -21.708,  -15.772,   13.416], # 14 3-3
	[   8.292,  -25.520,   13.416], # 15 3-4
	[  28.532,    9.270,    0.000], # 16 4-0
	[  17.634,   24.271,    0.000], # 17 4-1
	[   0.000,   30.000,    0.000], # 18 4-2
	[ -17.634,   24.271,    0.000], # 19 4-3
	[ -28.532,    9.271,    0.000], # 20 4-4
	[ -28.532,   -9.270,    0.000], # 21 4-5
	[ -17.634,  -24.271,    0.000], # 22 4-6
	[   0.000,  -30.000,    0.000], # 23 4-7
	[  17.634,  -24.271,    0.000], # 24 4-8
	[  28.532,   -9.270,    0.000], # 25 4-9
	[  21.708,   15.772,  -13.416], # 26 5-0
	[  -8.292,   25.520,  -13.416], # 27 5-1
	[ -26.833,    0.000,  -13.416], # 28 5-2
	[  -8.292,  -25.520,  -13.416], # 29 5-3
	[  21.708,  -15.772,  -13.416], # 30 5-4
	[  25.520,    0.000,  -15.772], # 31 6-0
	[   7.886,   24.271,  -15.772], # 32 6-1
	[ -20.646,   15.000,  -15.772], # 33 6-2
	[ -20.646,  -15.000,  -15.772], # 34 6-3
	[   7.886,  -24.271,  -15.772]  # 35 6-4
        ]

# Edges: 95
E = [
	[ 0,  1,   16.400, "-"], #   0
	[ 1,  2,   18.540, "-"], #   1
	[ 2,  0,   16.400, "-"], #   2
	[ 1, 11,   16.400, "-"], #   3
	[11,  6,   16.400, "-"], #   4
	[ 6,  1,   18.540, "-"], #   5
	[ 6,  2,   18.540, "-"], #   6
	[ 6, 12,   16.400, "-"], #   7
	[12,  2,   16.400, "-"], #   8
	[ 2,  3,   18.540, "-"], #   9
	[ 3,  0,   16.400, "-"], #  10
	[12,  7,   16.400, "-"], #  11
	[ 7,  2,   18.540, "-"], #  12
	[ 7,  3,   18.540, "-"], #  13
	[ 7, 13,   16.400, "-"], #  14
	[13,  3,   16.400, "-"], #  15
	[ 3,  4,   18.540, "-"], #  16
	[ 4,  0,   16.400, "-"], #  17
	[13,  8,   16.400, "-"], #  18
	[ 8,  3,   18.540, "-"], #  19
	[ 8,  4,   18.540, "-"], #  20
	[ 8, 14,   16.400, "-"], #  21
	[14,  4,   16.400, "-"], #  22
	[ 4,  5,   18.540, "-"], #  23
	[ 5,  0,   16.400, "-"], #  24
	[14,  9,   16.400, "-"], #  25
	[ 9,  4,   18.540, "-"], #  26
	[ 9,  5,   18.540, "-"], #  27
	[ 9, 15,   16.400, "-"], #  28
	[15,  5,   16.400, "-"], #  29
	[ 5,  1,   18.540, "-"], #  30
	[15, 10,   16.400, "-"], #  31
	[10,  5,   18.540, "-"], #  32
	[10,  1,   18.540, "-"], #  33
	[10, 11,   16.400, "-"], #  34
	[ 6, 16,   18.540, "-"], #  35
	[16, 11,   16.400, "-"], #  36
	[12, 17,   16.400, "-"], #  37
	[17,  6,   18.540, "-"], #  38
	[17, 16,   18.540, "-"], #  39
	[17, 26,   16.400, "-"], #  40
	[26, 16,   16.400, "-"], #  41
	[17, 18,   18.540, "-"], #  42
	[18, 12,   16.400, "-"], #  43
	[26, 32,   16.400, "-"], #  44
	[32, 17,   18.540, "-"], #  45
	[32, 18,   18.540, "-"], #  46
	[32, 27,   16.400, "-"], #  47
	[27, 18,   16.400, "-"], #  48
	[ 7, 18,   18.540, "-"], #  49
	[13, 19,   16.400, "-"], #  50
	[19,  7,   18.540, "-"], #  51
	[19, 18,   18.540, "-"], #  52
	[19, 27,   16.400, "-"], #  53
	[19, 20,   18.540, "-"], #  54
	[20, 13,   16.400, "-"], #  55
	[27, 33,   16.400, "-"], #  56
	[33, 19,   18.540, "-"], #  57
	[33, 20,   18.540, "-"], #  58
	[33, 28,   16.400, "-"], #  59
	[28, 20,   16.400, "-"], #  60
	[ 8, 20,   18.540, "-"], #  61
	[14, 21,   16.400, "-"], #  62
	[21,  8,   18.540, "-"], #  63
	[21, 20,   18.540, "-"], #  64
	[21, 28,   16.400, "-"], #  65
	[21, 22,   18.540, "-"], #  66
	[22, 14,   16.400, "-"], #  67
	[28, 34,   16.400, "-"], #  68
	[34, 21,   18.540, "-"], #  69
	[34, 22,   18.540, "-"], #  70
	[34, 29,   16.400, "-"], #  71
	[29, 22,   16.400, "-"], #  72
	[ 9, 22,   18.540, "-"], #  73
	[15, 23,   16.400, "-"], #  74
	[23,  9,   18.540, "-"], #  75
	[23, 22,   18.540, "-"], #  76
	[23, 29,   16.400, "-"], #  77
	[23, 24,   18.540, "-"], #  78
	[24, 15,   16.400, "-"], #  79
	[29, 35,   16.400, "-"], #  80
	[35, 23,   18.540, "-"], #  81
	[35, 24,   18.540, "-"], #  82
	[35, 30,   16.400, "-"], #  83
	[30, 24,   16.400, "-"], #  84
	[10, 24,   18.540, "-"], #  85
	[11, 25,   16.400, "-"], #  86
	[25, 10,   18.540, "-"], #  87
	[25, 24,   18.540, "-"], #  88
	[25, 30,   16.400, "-"], #  89
	[16, 25,   18.540, "-"], #  90
	[26, 31,   16.400, "-"], #  91
	[31, 16,   18.540, "-"], #  92
	[31, 25,   18.540, "-"], #  93
	[31, 30,   16.400, "-"]  #  94
        ]

# Faces: 60
F = [
	[ 0,  1,  2], #  0 
	[ 1, 11,  6], #  1 
	[ 1,  6,  2], #  2 
	[ 2,  6, 12], #  3 
	[ 0,  2,  3], #  4 
	[ 2, 12,  7], #  5 
	[ 2,  7,  3], #  6 
	[ 3,  7, 13], #  7 
	[ 0,  3,  4], #  8 
	[ 3, 13,  8], #  9 
	[ 3,  8,  4], # 10 
	[ 4,  8, 14], # 11 
	[ 0,  4,  5], # 12 
	[ 4, 14,  9], # 13 
	[ 4,  9,  5], # 14 
	[ 5,  9, 15], # 15 
	[ 0,  5,  1], # 16 
	[ 5, 15, 10], # 17 
	[ 5, 10,  1], # 18 
	[ 1, 10, 11], # 19 
	[11,  6, 16], # 20 
	[ 6, 12, 17], # 21 
	[ 6, 17, 16], # 22 
	[16, 17, 26], # 23 
	[12, 17, 18], # 24 
	[17, 26, 32], # 25 
	[17, 32, 18], # 26 
	[18, 32, 27], # 27 
	[12,  7, 18], # 28 
	[ 7, 13, 19], # 29 
	[ 7, 19, 18], # 30 
	[18, 19, 27], # 31 
	[13, 19, 20], # 32 
	[19, 27, 33], # 33 
	[19, 33, 20], # 34 
	[20, 33, 28], # 35 
	[13,  8, 20], # 36 
	[ 8, 14, 21], # 37 
	[ 8, 21, 20], # 38 
	[20, 21, 28], # 39 
	[14, 21, 22], # 40 
	[21, 28, 34], # 41 
	[21, 34, 22], # 42 
	[22, 34, 29], # 43 
	[14,  9, 22], # 44 
	[ 9, 15, 23], # 45 
	[ 9, 23, 22], # 46 
	[22, 23, 29], # 47 
	[15, 23, 24], # 48 
	[23, 29, 35], # 49 
	[23, 35, 24], # 50 
	[24, 35, 30], # 51 
	[15, 10, 24], # 52 
	[10, 11, 25], # 53 
	[10, 25, 24], # 54 
	[24, 25, 30], # 55 
	[11, 16, 25], # 56 
	[16, 26, 31], # 57 
	[16, 31, 25], # 58 
	[25, 31, 30]  # 59 
        ]

# Edge types: 2
ET = [
	[16.4, 1, 1, 0, 0, 50], #0 
	[18.54, 2, 0, 1, 0, 45] #1 
        ]


from sortedome import *

global max_dst
# global Master_table 

#
# Create a dictionary of all the vertices that map each index to a 3D point.
# 
def create_vertex_dict(src):
        d = dict()
        for i in range(len(src)):
                key = i
                x, y, z = src[i]
                value = Point(x, y, z, prec=3)
                d[key] = value
 
        return d
#
#  Create a dictionary of all the edges.    
#  [16.4, 1, 1, 0, 0, 50]
def create_edge_table(src):
        buf = list()

        for i in range(len(src)):
                item = src[i]
                edge = (item[0], item[1])            # (length, type) 
                buf.append(edge)

        return tuple(buf)

# Convert length to type 
def eg_len2type(length):
        for it in Edge_table:
                l, t = it
                if l == length:
                        return t

# Convert type to length 
def eg_type2len(type_):
        for it in Edge_table:
                l, t = it
                if t == type_:
                        return l

# Read-only vertex table  
Master_table = create_vertex_dict(V)

# Read-only edge table 
Edge_table = create_edge_table(ET)

# helper function
# src: list of (0,  Point)
# Output: vector of  [1, [0.0, 0.0, 30.0]],...
def export_openscad_vector(hub_center, sph_center, src):
        x, y, z = hub_center.xyz()
        cuid = src[0][0]
        r, theta, phi = sph_center.value()
        
        print('// {}, [{}, {}, {}]'.format(cuid, x, y, z))
        print('// r = {}, theta = {}, phi = {}'.format(r, theta, phi))
        print('H = [')
        for it in src:
                uid = it[0]
                x, y, z = it[1].xyz()
                print('\t[{}, [{}, {}, {}]],'.format(uid, x, y, z))        
        print('];') 


# Unique Vertex
class UniqueVertex:
        ''' It contains all 3-dimensional information to build hub model.
                p: Point(x, y, z) 
                level: a level that contains vertices which share equal height 
                level_size: number of vertices in a level 
                rid: index of the vertex in a level  
                uid: unique index of vertex 
        '''
        Level = None   # VertexLevel object 

        def __init__(self, pt, uid, rid, level, level_size):
                self.uid = uid
                self.point = pt
                self.level = level
                self.level_size = level_size
                self.rid = rid 

        def get_uid(self, level, level_size, rid):
                pass

        def __str__(self):
                x, y, z = self.point.xyz()
                pt = '({}, {}, {})'.format(x, y, z) 
                text = 'uVertex<{}, {}, {}, {}, {}>'.format(
                                self.uid,
                                self.rid,
                                self.level,
                                self.level_size,
                                pt)
                return text

#
# Frequency 2, 36 vertices  
#
# 0 [0]
# 1 [1, 2, 3, 4, 5]
# 2 [6, 7, 8, 9, 10]
# 3 [11, 12, 13, 14, 15]
# 4 [16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
# 5 [26, 27, 28, 29, 30]
# 6 [31, 32, 33, 34, 35]
#
# The layout of vertices in 2nd and 3rd level on XY plane
#
#     7     2     6
#                 
#      3    0   1
#   8              10 
#        4     5
#            
#           9
#
class VertexLevel:
        ''' Store indices of ordered vertices by equal height 
                Level: dictionary  
        '''

        def __init__(self, vsrc):
                self.Level = self.create_levels(vsrc) 
                self.size = len(self.Level)
                self.uVertex = self.generate_uvertex(vsrc) 

        #  [   0.000,    0.000,   30.000], #  0 0-0
        def create_levels(self, vsrc):
                tt, t, i = list(), list(), 0
                level = 0
                oldz = vsrc[0][2] 
                for i in range(len(vsrc)):
                        _curr = vsrc[i]
                        currz = _curr[-1]
                        index = i 
                        if oldz != currz:
                                level += 1
                                tt.append(t[:])
                                del t[:]
                        t.append(index)
                        oldz = currz
                tt.append(t[:])         # last element 

                d = dict()
                for i in range(len(tt)):
                        key = i
                        val = tt[i]     # a level 
                        d[key] = val 
                del t[:], tt[:]

                return d 

        def get_level(self, pos):
                if pos in self.Level.keys():
                        return self.Level[pos]

        def show(self):
                print('{} levels'.format(self.size))
                print('key size  data')
                print('--------------')
                for key, val in self.Level.items():
                        print('{:3d}  {:3d}  {}'.format(key, len(val), val))

        def get_rid(self, uid):
                ''' uid: Unique index 
                    Return triple: rid, level, size
                        rid: relative id of the vertex in a level
                        level: the level number 
                        size: size of the level
                '''
                i, pos, size, found = 0, 0, 0, False
                rid = 0
                while i < self.size and not found:
                        tmp = self.get_level(i)
                        j, size = 0, len(tmp)
                        while j < size:
                                if uid == pos:
                                        found = True
                                        rid = j
                                        break
                                else:
                                        pos += 1
                                j += 1
                        i += 1 

                level = 0 if i is 0 else i-1 
                ECHO('uid: {}, pos: {}'.format(uid, pos), False)
                ECHO('level: {}, rid: {}, size: {}'.format(level, rid, size),
                                False)
                return rid, level, size
       
        def uvertex(self, uid, triple):
                x, y, z = triple
                p = Point(x, y, z, prec=3)
                rid, l, sz = self.get_rid(uid)
                return UniqueVertex(p, uid, rid, l, sz)

        def generate_uvertex(self, vsrc):
                t = list()
                for uid in range(len(vsrc)):
                        uv = self.uvertex(uid, vsrc[uid])
                        t.append(uv)

                return t 

#
# Store all edges in a Hub 
# 
# center: Hub.uid               center vertex's uid 
# radial_x: Hub.Sorted_index    radial edges  
# side_x: Hub.Sorted_spoke      side edges 
#
class HubEdge:
        
        def __init__(self, center, radialx, sidex):
                self.uid = center 
                
                self.Radial = list()
                for it in radialx:
                        item = self.create_edge(self.uid, it[0])
                        self.Radial.append(item)
                
                self.Side = list()
                for it in sidex:
                        ia, ib = it[0]
                        item = self.create_edge(ia, ib)
                        self.Side.append(item)

                self.count = len(self.Radial) + len(self.Side)                        
                self.key = self.create_key() 

        #
        # Calculate length of each edge. 
        # Return((ia, ib), length, type)
        #
        def create_edge(self, ia, ib):
                a, b = Master_table[ia], Master_table[ib]
                length = ptDist(a, b, prec=2)
                type_ = eg_len2type(length) 
                
                return ((ia, ib), length, type_)
       
        # Collect all edge types and make a string key 
        def create_key(self):
                buf = list()
                for it in self.Radial:
                        buf.append(it[-1])
                for it in self.Side:
                        buf.append(it[-1])

                key = '-'.join(map(str, buf))
                del buf[:]
                return key

        def __str__(self):

                def text_body(src):
                        TAB = 2*' '
                        pair, length, type_ = TAB, TAB, TAB 
                        for it in src:
                                p, l, t = it
                                pair += '{}-{} '.format(p[0], p[1])
                                length += '{} '.format(l)
                                type_ += '{} '.format(t)
                        output = '{} \n {} \n {} \n'.format(pair, length, type_)

                        return output

                title = 'Edge: {}\n'.format(self.count)
                radial_body = text_body(self.Radial)
                tradial = '  Radial:\n {}'.format(radial_body)
                side_body = text_body(self.Side)
                tside = '  Side: \n {}'.format(side_body)

                return title + tradial + tside 

#
# Store all faces.
# One side edge and center form a triangle ABC. 
#          B
#          +  
#  A       | 
#  +       |
#          |
#          +  
#          C 
#
# A: Hub.uid                    center vertex's uid
# sidex: Hub.Sorted_spoke       side edges
class HubFace:

        def __init__(self, A, sidex):
                self.data = list()
                self.A = A

                # Side edges 
                for it in sidex:
                        B, C = it[0]
                        self.data.append((self.A, B, C))
                
                self.count = len(self.data)

        def __str__(self):
                title = 'Face: {}\n'.format(self.count)
                body = 2*' ' 
                for it in self.data:
                        A, B, C = it
                        body += '{}-{}-{} '.format(A, B, C)

                return title + body 

#       
# Hub is basic data type to create a 3D model.  
# It contains vectors that represent spokes, bend angles, and acute angles.
#
# Outer vertices and one center vertex forms one hub
# Each spoke, i.e 0-1, has one bend angle. 
#
# The first hub whose uid is 0:  
# vector(0, 1), vector(0, 2), vector(0, 3)
# vector(0, 4), vector(0, 5)
#
#            2 
#                  
#                  
#     3             1  
#            0     
# 
#      
#       4         5 
#
#
# A hub has 3 to 6 acute angles formed by two ajacent spokes. 
# Each spoke maps to unique vectors paired with center and an outer vertex.
# Below is the 2nd hub, which has 6 spokes:
#
# vector(1, 0), vector(1, 2), vector(1, 5), 
# vector(1, 6), vector(1, 10), vector(1, 11).
#
# These vectors form 6 acute angles. 
# angle_0: vector(1, 0), vector(1, 2)
# angle_1: vector(1, 2), vector(1, 6) 
# angle_2: vector(1, 6), vector(1, 11)
# angle_3: vector(1, 11), vector(1, 10)
# angle_4: vector(1, 10), vector(1, 5)
# angle_5: vector(1, 5), vector(1, 0)
#
#       6
#  2        11
#       1
#  0        10
#       5
#
class Hub:
        ''' uid: unique index of the center vertex
            center: center vertex
            spokes: outer vertices 
        '''
        def __init__(self, center, spokes):
                self.tag = None                 # (Edge.count, Edge.key)  

                self.uid = center.uid           # center 
                self.center = center
                self.Spoke = spokes 
                self.scenter = None             # Spherical cooridnate of center 
                self.Rspoke = None              # Rotated vertices to top center 

                # Sorted indices of the vertices.
                # It also contains side angles beween spokes.
                self.Sorted_index = None         

                # list of ((i1, i2), angle, vector_a, vector_b)
                self.Sorted_spoke = None        
                self.Sorted_spoke2 = None       # Rotated vertices to top center  
                self.Edge = None                # All edges  
                self.Face = None                # All faces 

        # Show only indices 
        def show(self):
                s1 = '{}: '.format(self.uid)
                s2 = ''
                for it in self.Spoke:
                        s2 += '{} '.format(it.uid)
                print(s1 + s2)

        # Show Hub data 
        def deepshow(self):
                if self.Sorted_index is None:
                        print('Run process() first.')
                        return 

                print('Hub: {}'.format(self.uid))
                print('Spherical coordinate of {} vertex'.format(self.uid))
                r, theta, phi = self.scenter.value()
                print('\t r = {}, theta = {}, phi = {}'.format(
                                        r, theta, phi))
                for it in self.Sorted_index:
                        print('{:6d}'.format(it[0]), end=' ')
                print()
                for it in self.Sorted_index:
                        print('{:6.2f}'.format(it[1]), end=' ')
                print()

                # (i1, i2), angle, vector_a, vector_b
                for it in self.Sorted_spoke:
                        pair, ang, a, b = it 
                        print('{}, {}, ({},{},{}) -> ({},{},{})'.format(
                                pair, 
                                ang,
                                a.x, a.y, a.z,
                                b.x, b.y, b.z))

                print(self.Edge)
                print(self.Face)
                print(self.Edge.key)

                # Test code 
                # ct = self.center.point
                # export_openscad_vector(ct.pt(), self.scenter, self.Rspoke)


        # (it, ang, a, b)
        def show_spoke(self, obj):
                index, ang, a, b = obj
                ta = '({:.2f}, {:.2f}, {:.2f})'.format(a.x, a.y, a.z)
                tb = '({:.2f}, {:.2f}, {:.2f})'.format(b.x, b.y, b.z)
                print('({}, {}, {} - {})'.format(index, ang, ta, tb))               

        #
        # Find coordinate of the base vector (x, 0, z)
        # sqrt(x^2 + 0^2 + z^2) = radius 
        # x^2 = (radius^2 - z^2) 
        # x = sqrt(radius^2 - z^2)
        def base_vector(self, r, vec, center):
                a = center[1]
                z = vec.z
                x = m.sqrt(r*r - z*z) 
                b = Point(x, 0.0, z, prec=2)
                return pt_vector(a, b)

        # 
        # vsrc: list of (index, Point)
        # center: 0th vector 
        # base vector: 1th vector 
        #
        def base_vector2(self, r, vsrc):
                _ct = vsrc[0]
                a = _ct[1]
                _t = vsrc[1]
                p = _t[1].pt()
                z = p.z
                x = m.sqrt(r*r - z*z)
                b = Point(x, 0.0, z, prec=2)

                return pt_vector(a, b)


        # [(1, Point(0.0, 0.0, 30.0)), ...]
        # src: all vertices 
        def compute_vectors(self, src):
                first = src[0]
                center = first[1]
                others = src[1:]

                buf = list()
                for it in others:
                        v = it[1]
                        vec = pt_vector(center, v)
                        buf.append((it[0], vec))

                return buf


        # the base vector is on X axis of XY plane.
        def compute_x_angles(self, base_vec, src):
                
                def get_key(item):
                        return item[1]

                x0, y0 = base_vec.x, base_vec.y
                buf = list()
                for it in src:
                        b = it[1]
                        deg = calculate_angle(b.x, b.y, x0, y0) 
                        buf.append((it[0], deg))

                # Sorting angles
                return sorted(buf, key=get_key)

        #
        # Compute the angle between each pair of ajacent spokes 
        # and all vectors. 
        # The number of angles matches total number of spokes.
        #
        # ex 1) [11, 6, 2, 0, 5, 10]
        # (11, 6), (6, 2), (2, 0), (0, 5), (5, 10), (10, 11)
        #
        # ex 2) [26, 16, 25, 30]
        # (26, 16), (16, 25), (25, 30) 
        # (30, 26) can not work because the distance is too big. 
        #
        def compute_spoke(self, src, vsrc):
                global max_dst

                vectors = dict()
                for it in vsrc:
                        key, vec = it           # (index, Point)
                        vectors[key] = vec 

                # extract uids 
                src2 = list()
                for it in src:
                        src2.append(it[0])

                # Find all spoke pairs 
                pair = list()
                i, end = 0, len(src2)
                while i < end-1: 
                        a = src2[i] 
                        b = src2[i+1]
                        pair.append((a, b))
                        i += 1

                # Verify condition of the last pair  
                ih, it = src2[0], src2[-1] 
                last_item = (ih, it)
                head, tail = vectors[ih], vectors[it]
                if ptDist(head, tail, prec=2) <= max_dst:
                        pair.append(last_item)

                angles = list()
                for it in pair:
                        _a, _b = it 
                        a = vectors[_a]
                        b = vectors[_b]
                        ang = vector_angle(a, b)
                        item = (it, ang, a, b)
                        angles.append(item)
                del pair[:]
                del src2[:]

                return angles 

        def rotate_vertices(self, phi, theta, top_center):
                t = list()
                tc = RzRy(phi, theta, top_center)
                t.append((self.uid, tc))
                for it in self.Spoke:
                        tvec = RzRy(phi, theta, it.point)
                        t.append((it.uid, tvec))
                
                return t

        #
        # Rotate all vertices to the top position (0.0, 0.0, r) 
        #
        # - create list of new vertices [center, 1st, 2nd, ... ] 
        # - find a base vector - vec(center, (x, 0.0, z))
        def process(self):
                ct = self.center.point
                self.scenter = get_sph_coordinate(ct)
                r, theta, phi = self.scenter.value()

                # Original vertices 
                vsrc = list()
                vsrc.append((self.uid, ct))
                for it in self.Spoke:
                        vsrc.append((it.uid, it.point))
                vectors = self.compute_vectors(vsrc)

                self.Rspoke = self.rotate_vertices(phi, theta, ct) 
                bv = self.base_vector2(r, self.Rspoke)
                vectors2 = self.compute_vectors(self.Rspoke)
                self.Sorted_index = self.compute_x_angles(bv, vectors2)
                self.Sorted_spoke = self.compute_spoke(self.Sorted_index, vectors)

                # Debugging code
                # self.Sorted_spoke2 = self.compute_spoke(self.Sorted_index, vectors2)
                if self.Sorted_index is None or self.Sorted_spoke is None:
                        print('Hub.process(): Critical error!')
                        return 
                self.Edge = HubEdge(self.uid, self.Sorted_index,
                                self.Sorted_spoke)
                self.Face = HubFace(self.uid, self.Sorted_spoke)
                self.tag = (self.Edge.count, self.Edge.key)

                # self.deepshow()

# 
# Find the longest edge 
#
#ET = [
#        [16.4, 1, 1, 0, 0, 50], #0 
#        [18.54, 2, 0, 1, 0, 45] #1 
#        ]
#
def max_distance(esrc):
        t = list()
        for i in range(len(esrc)):
                d = esrc[i][0]
                t.append(d)
        t.sort()

        # last item is the longest  
        return t[-1]  

# How to calculate the range of vertices in a level? 
def get_all_vertices(index, level, uV):
        if type(level) is type([]):
                start = level[0]
                end = level[-1]
                ECHO("get_all_vertices():{}-({}, {})".format(index, start,
                                        end), False)
                end += 1
                return uV[start:end]

                
# targets are the keys 
# L is dictionary 
def find_ajacent_vertex(uid, targets, L, uV):
        _oo = False
        global max_dst

        center = uV[uid]
        others = list()

        # Create one list 
        for key in targets:
                row = get_all_vertices(key, L[key], uV)
                others.extend(row)                        

        # Find 4 to 6 ajacent vertices 
        av = list()
        # limit = max_dst * 1.5
        for v in others:
                d = ptDist(center.point, v.point, prec=2)
                if d <= max_dst:
                        ECHO('\t[{}]: {} vs {}'.format(v.uid, d, max_dst),
                                        _oo)
                        av.append(v)
        av.remove(center)

        return av

#
#  Triangle ABC has a right angle at C.
#
#   A
#   +
#   |        c
# b |
#   |
# C +-----------------+ B
#   .        a
#   .
#   |
# O +
#
#  OA = OB = r (radius)
#  AB = c (hypotenuse)
#  
#  b = c cos(angle_A)
#  a = c sin(angle_A)
#
#   
#  vector(C, B) lays on a plane that vector(C, A) is normal to it.
#  Use vector(C, B) to sort other vertices by the angle formula. 
#
#  CA
# ---- = scale_factor_1 
#  OA 
#
#  OC     OA - CA     r-b         b
# ---- = --------- = ----- = 1 - --- 
#  OA        OA        r          r
#
# OC = (1 - b/r) * OA
#
# C = (1 - b/r) * A 
#    
# Let f = (1 - b/r) 
# C = f*A
#
# C = (f*A.x, f*A.y, f*A.z). 
# 
def find_point_on_plane(A, B):
        ''' 
            A and B are Point objects.
            A: uid
            B: other
            Return a Point object C that forms a plane with B. 
        '''
        r = vlen(A)                     # OA 
        angO = vector_angle(A, B)
        angA = 90.0 - (angO/2.0) 
        c = ptDist(A, B)                # AB

        x = m.radians(angA)
        b = c * m.cos(x)                # CA

        f = 1.0 - b/r                   # scale factor
        x, y, z = f*A.x, f*A.y, f*A.z   # OC                     
        C = Point(x, y, z)
        OC = vlen(C)
        vecCB = pt_vector(C, B)        # vector CB  

        _oo = True
        ECHO('vector A = {}'.format(A), _oo)
        ECHO('vector B = {}'.format(B), _oo)
        ECHO('angle A = {}'.format(angA), _oo)
        ECHO('c = {}'.format(c), _oo)
        ECHO('OA = {:.4}'.format(r), _oo)
        ECHO('C = ({:.4}, {:.4}, {:.4})'.format(C.x, C.y, C.z), _oo)
        ECHO('CA = {:.4}'.format(b), _oo)
        ECHO('vector(C, B) = {}'.format(vecCB), _oo)
        t = OC + b 
        ECHO('OC + CA = {:.4}'.format(t), _oo) 
        
        return C

#
# L: Levels
# uV: UniqueVertex objects 
def create_hub(uid, L, uV):
        targets = list()
        the_end = len(L) - 1

        # Find the level that contains uid
        for it in uV:
                if uid is it.uid:
                       curr = it.level
                       break

        # Exclusive two levels: top and bottom 
        if curr is 0:
                targets.append(curr)
                targets.append(curr+1)
        elif curr is the_end:
                targets.append(curr-2)
                targets.append(curr-1)
                targets.append(curr)
        else:
                if curr-2 > 0:
                        targets.append(curr-2)
                targets.append(curr-1)
                targets.append(curr)
                targets.append(curr+1)
                if curr+2 <= the_end:
                        targets.append(curr+2)
         
        # Find ajacent vertices 
        center = uV[uid]
        spokes = find_ajacent_vertex(uid, targets, L, uV)
        return Hub(center, spokes)

# bend_angle(), bend_angle2() 
# a, b: UniqueVertex objects
def test_func(a, b):
        a1 = bend_angle(a.point, b.point)
        a2 = bend_angle2(a.point, b.point)
        print('bend_angle(): ', a1)
        print('bend_angle2(): ', a2)


if __name__ == '__main__':
        max_dst = max_distance(ET)
        vL = VertexLevel(V)

        Hubs = list()
        for i in range(len(vL.uVertex)):
                h = create_hub(i, vL.Level, vL.uVertex)
                h.process()
                Hubs.append(h)
        print('{} hubs created.'.format(len(Hubs)))

        for i in range(len(Hubs)):
                h = Hubs[i]
                print(h.uid, h.tag)


